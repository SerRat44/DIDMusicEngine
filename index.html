<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>newAudioEngine</title>
<style>
body {
  font-family: monospace;
  display: flex;
  flex-direction: column;
  margin: 4px;
  overflow-y: auto;
  background-color: #f2f2f2;
  text-align: center;
}
button {
    margin-bottom: 1rem;
}
.song-section {
  display: flex;
  justify-content: space-evenly;
  margin-bottom: 1rem;
}
.song-column {
  display: flex;
  flex-direction: column;
  align-items: center;
}
</style>
</head>

<body>
<div id="titleScreen">
  <h1>New Audio Engine</h1>
  <button id="startBtn">Start</button>
</div>

<div id="contentWrapper" style="display: none;">
  <input id="seedInput" type="text" placeholder="Enter custom seed">
  <button id="generateBtn">Generate Song</button>
  <button id="nextPatternBtn">Next Pattern</button>
  <div id="patternId"></div>
  <div id="songDisplay"></div>
</div>

<script>

// helper/seed functions


function choose(array) {
    return array[Math.floor(rnd() * array.length)];
}

function rndInt(max) {
    return Math.floor(rnd() * max);
}

function fill(count, fn) {
    return new Array(count).fill(undefined).map((x, i) => fn(i));
}

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        var t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

function xmur3(str) {
    for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = h << 13 | h >>> 19;
    }
    return function() {
        h = Math.imul(h ^ h >>> 16, 2246822507);
        h = Math.imul(h ^ h >>> 13, 3266489909);
        return (h ^= h >>> 16) >>> 0;
    }
}

let randomFunction = Math.random;

function rnd() {
    return randomFunction();
}

function seedRNG(seed) {
    const seedHasher = xmur3(seed);
    randomFunction = sfc32(seedHasher(), seedHasher(), seedHasher(), seedHasher());
}
//end helper/seed functions

const scales = {
    //major: [0, 2, 3, 5, 7, 8, 10],
    //minor: [0, 2, 4, 5, 7, 9, 11],
    major: [0, 2, 3, 5, 6, 8, 9, 11], //diminished
	minor: [0, 1, 4, 5, 7, 8, 10],  //phrygianDominant
	//harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
    //phrygianDominant: [0, 1, 4, 5, 7, 8, 10],
    //locrian: [0, 1, 3, 5, 6, 8, 10],
    //diminished: [0, 2, 3, 5, 6, 8, 9, 11],
};

const chordTypes = {
    triad: [0, 2, 4],
};

function modulate(key, scale) {
    choose([
        function() {
            // Move to relative major or minor
            if (scale === scales.minor) {
                scale = scales.major;
                key = (key + 3) % 12;
            } else if (scale === scales.major) {
                scale = scales.minor;
                key = (key + 9) % 12;
            }
        },
        function() {
            // Move around the cycle of fifths
            if (Math.random() < 0.5) {
                key = (key + 7) % 12;
            } else {
                key = (key + 5) % 12;
            }
        },
    ])();
    return [key, scale];
}

const PatternSize = 64;

function flip(trueChance = 0.5) {
    return rnd() < trueChance;
}

function getChord(context, rowIndex) {
    const { progression, key, scale } = context;
    const progIndex = Math.floor(rowIndex / 4);
    const chordNumber = progression[progIndex];
    return chordTypes.triad.map(noteIndex => key + scale[(chordNumber - 1 + noteIndex) % scale.length]);
}

function arp(context) {
    const octave = choose([0, 12, 24]);
    const offset = choose([0, 1, 2]);
    const pwOffset = rndInt(8) * 2;
    const pwCycle = choose([4, 5, 6, 8, 12, 16]);
    return fill(PatternSize, i => {
        const chord = getChord(context, i);
        return {
            note: chord[(i + offset + choose([0, 0, 0, 1, 2])) % chord.length] + octave + choose([0, 12]),
            fx: {
                pulseWidth: ((pwOffset + i) % pwCycle) / (pwCycle + 1),
            },
        };
    });
}

function bass(context) {
    return fill(PatternSize, i => {
        const chord = getChord(context, i);
        const palmMute = flip(0.5) ? 0.5 : 1; // 50% chance of palm-muted notes
        return {
            note: i % 2 === 1 ? 'cont' : chord[0] + (Math.floor(i / 2) % 2) * 12 - 12,
            vel: palmMute,
            fx: { pulseWidth: 0 },
        };
    });
}

function bass2(context) {
    return fill(PatternSize, i => {
        const chord = getChord(context, i);
        return { note: i % 8 === 0 ? ((chord[0] + 4) % 12) - 4 : 'cont', vel: 2, fx: { pulseWidth: rnd() } };
    });
}

function melody1(context) {
    const slow = flip();
    const pwmMod = flip();
    let pwmAmount = rnd() * 0.5;

    const pattern = [];
    let current = (choose(chordTypes.triad) - 1) + context.scale.length * choose([2, 3, 4]);
    for (let i = 0; i < PatternSize; i++) {
        pwmAmount += flip() ? 0.05 : -0.05;
        pwmAmount += pwmAmount > 0.7 ? -0.05 : pwmAmount < 0.1 ? 0.05 : 0;

        if (slow && i % 2 === 1 || flip(0.1 + 0.4 * (1 - i % 2))) {
            pattern.push({ note: "cont", fx: { pulseWidth: pwmMod ? pwmAmount : 0 } });
        } else {
            if (current > 10 && flip()) {
                current--;
            } else if (current < 32 && flip()) {
                current++;
            } else if (current > 15 && flip(0.2)) {
                current -= choose([2, 4, 7]);
            } else if (current < 25 && flip(0.2)) {
                current += choose([2, 4, 7]);
            }
            const chord = getChord(context, i);

            if (flip() && !chord.includes(current % context.scale.length)) {
                current += flip() ? -1 : 1;
            }

            pattern.push({
                note: context.key + context.scale[current % context.scale.length] + Math.floor(current / context.scale.length) * 12,
                fx: {
                    glide: flip(0.2) ? choose([0.1, 0.2, 0.5, 0.7]) : 0,
                    pulseWidth: pwmMod ? pwmAmount : 0
                }
            });
        }
    }
    return pattern;
}

function powerChord(rootNote) {
    return [rootNote, rootNote + 7];
}

function riff(context) {
    const octave = choose([0, 12, 24]);
    const pattern = [];
    for (let i = 0; i < PatternSize; i++) {
        const chord = getChord(context, i);
        const rootNote = chord[0] + octave;
        const powerChordNotes = powerChord(rootNote);
        const usePowerChord = flip(0.7);
        const palmMute = flip(0.5) ? 0.5 : 1; // 50% chance of palm-muted notes
        pattern.push({
            note: usePowerChord ? choose(powerChordNotes) : rootNote,
            vel: palmMute,
            fx: {
                glide: flip(0.2) ? choose([0.1, 0.2, 0.5, 0.7]) : 0,
            },
        });
    }
    return pattern;
}



function emptyNote() {
    return fill(PatternSize, _ => ({ note: '---' }));
}

function emptyDrum() {
    return fill(PatternSize, _ => ({ drum: '---' }));
}

function drum() {
    return fill(PatternSize, i => ({
        drum: i % 8 === 0 ? 'KCK' :
            i % 8 === 4 ? 'SNR' :
                (i % 2 === 0 && flip(0.2)) ? 'KCK' :
                    flip(0.05) ? choose(['KCK', 'SNR']) : 'NSS',
        vel: 0.6 + 0.2 * (1 - (i % 2))
    }));
}

function metalDrum() {
    return fill(PatternSize, i => ({
        drum: i % 8 === 0 ? 'KCK' :
            i % 8 === 4 ? 'SNR' :
                (i % 2 === 0 && flip(0.6)) ? 'KCK' :
                    flip(0.2) ? choose(['KCK', 'SNR']) : 'NSS',
        vel: 0.6 + 0.2 * (1 - (i % 2)),
        doubleBass: i % 4 === 2 ? 'KCK' : '---', // Add double bass drum hits
    }));
}




const progressions = [
    [1, 1, 6, 6, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 6, 6],
    [1, 1, 6, 6, 4, 4, 5, 5, 1, 1, 6, 6, 3, 3, 5, 5],
    [4, 4, 5, 5, 1, 1, 1, 1, 5, 5, 6, 6, 1, 1, 1, 1],
    [1, 1, 4, 4, 5, 5, 1, 1, 6, 6, 4, 4, 5, 5, 1, 1],
    [5, 5, 4, 4, 1, 1, 1, 1, 5, 5, 6, 6, 1, 1, 1, 1],
    [6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5],
    [1, 1, 1, 1, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5],
    [6, 6, 6, 6, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 5, 5],
	[1, 1, 5, 5, 6, 6, 2, 2, 1, 1, 5, 5, 6, 6, 3, 3],
	[6, 6, 1, 1, 4, 4, 3, 3, 6, 6, 1, 1, 5, 5, 2, 2],
	[1, 1, 6, 6, 2, 2, 5, 5, 1, 1, 6, 6, 4, 4, 3, 3],
	[5, 5, 1, 1, 6, 6, 4, 4, 5, 5, 1, 1, 3, 3, 2, 2]
];



function bpmClock() {
    let intervalHandle = {
        bpmClock: 0
    };
    let fN = 0;
    function set(bpm, frameFunction) {
        window.clearInterval(intervalHandle.bpmClock);
        intervalHandle.bpmClock = window.setInterval(() => frameFunction(fN++), (60000 / bpm) / 4);
    }
    return {
        set
    }
}

function mutateState(state) {
    state.songIndex++;
    if (state.songIndex % 8 === 0) {
        state.bpm = Math.floor(Math.random() * 40) + 140;
        //clock.set(state.bpm, frame);
    }
    if (state.songIndex % 4 === 0) {
        [state.key, state.scale] = modulate(state.key, state.scale);
    }
    if (state.songIndex % 2 === 0) {
        state.progression = choose(progressions);
    }
    state.seedCode = hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255));
    seedRNG(state.seedCode);

    //display.setPatterns(patterns, stateString);
}

function genTrack() {
    const seedOrSave = document.getElementById("seedInput").value;
    const state = createInitialState(seedOrSave);
	
    let patterns = [[], [], [], [], []];

    //const display = PatternDisplay(document.getElementById("display"));
    const clock = bpmClock();

    // @ts-ignore
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const au = Audio(ctx);
	
	const synths = [
    au.SquareSynth(),
    au.SquareSynth(-0.5),
    au.SquareSynth(),
    au.SquareSynth(0.5),
    au.DrumSynth()
];
   
    function newPatterns() {
        seedRNG(state.seedCode);
        patterns = [
            //choose([bass, bass2, emptyNote])(state),
           // Math.random() < 0.7 ? arp(state) : emptyNote(),
           // Math.random() < 0.7 ? melody1(state) : emptyNote(),
           // choose([emptyNote, arp, melody1])(state),
			//Math.random() < 0.8 ? drum() : emptyDrum(),
			
			
			choose([bass, bass2, emptyNote])(state),
			Math.random() < 0.7 ? riff(state) : emptyNote(),
			Math.random() < 0.7 ? riff(state) : emptyNote(),
			choose([emptyNote, riff])(state),
			Math.random() < 0.8 ? metalDrum() : emptyDrum(),
			

        ];
    }

    // create initial patterns
   
   newPatterns();
    //display.setPatterns(patterns, save(state));
	

	console.log(patterns);
		console.log(state);
		console.log(seedOrSave);
		console.log(save(state));


    function frame(f) {
        const positionInPattern = f % PatternSize;
        if (f % 128 === 0 && f !== 0) {
            mutateState(state);
            newPatterns();
            clock.set(state.bpm, frame);
            //display.setPatterns(patterns, save(state));
        }

        //display.highlightRow(positionInPattern);

        // Not a loop because these tuple parts have different types depending on melody vs drum
       synths[0].play(patterns[0][positionInPattern]);
        synths[1].play(patterns[1][positionInPattern]);
        synths[2].play(patterns[2][positionInPattern]);
        synths[3].play(patterns[3][positionInPattern]);
        synths[4].play(patterns[4][positionInPattern]);
    }

    clock.set(state.bpm, frame);
	
}




// save/load
function hex(v) {
    return Math.floor(v).toString(16).toUpperCase().padStart(2, '0');
}

function unhex(v) {
    return parseInt(v, 16);
}

function save(state) {
    const nonRandomElements = [state.key, state.scale === scales.major ? 0 : 1, progressions.indexOf(state.progression), state.bpm, state.songIndex % 256];
    const saveCode = "0x" + nonRandomElements.map(hex).join("") + state.seedCode;
    return saveCode;
}

function restore(code) {
    const codeString = code.slice(2);
    const key = unhex(codeString.slice(0, 2));
    const scale = unhex(codeString.slice(2, 4)) === 0 ? scales.major : scales.minor;
    const progression = progressions[unhex(codeString.slice(4, 6))];
    const bpm = unhex(codeString.slice(6, 8));
    const songIndex = unhex(codeString.slice(8, 10));
    const seedCode = codeString.slice(10);
    return {
        bpm,
        key,
        progression,
        scale,
        seedCode,
        songIndex
    };
}

function createInitialState(seedOrSave) {
    if (seedOrSave.startsWith("0x")) {
        return restore(seedOrSave);
    } else {
        const seed = (seedOrSave && seedOrSave.length > 0) ? seedOrSave : "" + Math.random();
        seedRNG(seed);
        return {
            key: rndInt(12),
            scale: scales.minor,
            progression: progressions[0],
            bpm: 152,
            seedCode: createSeedCode(),
            songIndex: 0
        };
    }
}

function createSeedCode() {
    return hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255)) + hex(Math.floor(Math.random() * 255));
}
// save/load


const A3Frequency = 440;
const A0Frequency = A3Frequency / 8;

function Audio(ctx) {
    function oscillatorNode(type, freq = 440) {
        const node = ctx.createOscillator();
        node.type = type;
        node.frequency.value = freq;
        return node;
    }
    function waveShaperNode(curve) {
        const node = ctx.createWaveShaper();
        node.curve = new Float32Array(curve);
        return node;
    }
    function gainNode(gainAmount = 0) {
        const node = ctx.createGain();
        node.gain.value = gainAmount;
        return node;
    }
    function stereoPannerNode(pan) {
        if (ctx.createStereoPanner) {
            const node = ctx.createStereoPanner();
            node.pan.value = pan;
            return node;
        } else {
            const node = ctx.createPanner();
            node.panningModel = "equalpower";
            node.setPosition(pan, 0, 0.5);
            node.pan = node.positionX;
            return node;
        }
    }

    function SquareSynth(pan = 0) {
        const set = (a, v) => { a.cancelScheduledValues(ctx.currentTime); a.setValueAtTime(v, ctx.currentTime); };
        const towards = (a, v, t) => { a.setTargetAtTime(t, ctx.currentTime, t) };
        const slide = (a, v, t) => { a.cancelScheduledValues(ctx.currentTime); a.setTargetAtTime(v, ctx.currentTime, t) };

        const wavetableTrigger = oscillatorNode("sawtooth"),
            pulseWavetable = waveShaperNode(new Float32Array(256).fill(-1, 0, 128).fill(1, 128, 256)),
            alwaysOneWavetable = waveShaperNode(new Float32Array(2).fill(1, 0, 2)),
            wavetableOffsetGain = gainNode(),
            pulseOutputGain = gainNode(),
            outputPanner = stereoPannerNode(pan);
        wavetableTrigger.start();
        wavetableTrigger.connect(pulseWavetable);
        wavetableTrigger.connect(alwaysOneWavetable);
        alwaysOneWavetable.connect(wavetableOffsetGain);
        wavetableOffsetGain.connect(pulseWavetable);
        pulseWavetable.connect(pulseOutputGain);
        pulseOutputGain.connect(outputPanner);
        outputPanner.connect(ctx.destination);

        const freq = wavetableTrigger.frequency,
            width = wavetableOffsetGain.gain,
            gain = pulseOutputGain.gain;

        const decay = 0.04, sustain = 0.7, release = 0.01, level = 0.1;

        function noteOn(note, glide = 0) {
            const glideTime = glide / 10;
            slide(freq, A0Frequency * 2 ** (note / 12), glideTime);
            set(gain, level);
            towards(gain, level * sustain, decay);
        }
        function noteOff() {
            slide(gain, 0, release);
        }
        function play(note) {
            if (note.note === "---") {
                noteOff();
            } else if (note.note === 'cont') {
                // do nothing
            } else {
                noteOn(note.note, note.fx?.glide);
            }
            set(width, note.fx?.pulseWidth ?? 0.0);
        }

        return { play }
    }
	
	function DrumSynth() {
    const toneOscillator = oscillatorNode("square", 55),
        toneGain = gainNode(),
        noiseWavetableTrigger = oscillatorNode("sawtooth", 20),
        noiseWavetable = waveShaperNode(fill(1024, x => rnd() * 2 - 1)),
        noiseGain = gainNode(),
        noisePan = stereoPannerNode(0);

    toneOscillator.start();
    noiseWavetableTrigger.start();

    toneOscillator.connect(toneGain);
    toneGain.connect(ctx.destination);

    noiseWavetableTrigger.connect(noiseWavetable);
    noiseWavetable.connect(noiseGain);
    noiseGain.connect(noisePan);
    noisePan.connect(ctx.destination);

    function play(slot) {
        const vel = slot.vel ? slot.vel : 1;
        if (slot.drum === 'KCK') {
            toneOscillator.detune.cancelScheduledValues(ctx.currentTime);
            toneOscillator.detune.setValueAtTime(3000, ctx.currentTime);
            toneOscillator.detune.setTargetAtTime(0, ctx.currentTime, 0.07);
            toneGain.gain.cancelScheduledValues(ctx.currentTime);
            toneGain.gain.setValueAtTime(0.2 * vel, ctx.currentTime);
            toneGain.gain.setValueCurveAtTime(new Float32Array([0.2 * vel, 0.2 * vel, 0.13 * vel, 0.05 * vel, 0.0]), ctx.currentTime, 0.10);
        } else if (slot.drum === 'NSS') {
            noiseGain.gain.cancelScheduledValues(ctx.currentTime);
            noiseGain.gain.setValueAtTime(0.1 * vel, ctx.currentTime);
            noiseGain.gain.setValueCurveAtTime(new Float32Array([0.1 * vel, 0.04 * vel, 0.0]), ctx.currentTime, 0.08);

            // Ugly workaround for safari being a bitch
            if ("pan" in noisePan) {
                noisePan.pan.cancelScheduledValues(ctx.currentTime);
                noisePan.pan.setValueAtTime(rnd() * 0.4 - 0.2, ctx.currentTime);
            }
        } else if (slot.drum === 'SNR') {
            toneOscillator.detune.cancelScheduledValues(ctx.currentTime);
            toneOscillator.detune.setValueAtTime(2400, ctx.currentTime);
            toneOscillator.detune.setTargetAtTime(600, ctx.currentTime, 0.04);
            toneGain.gain.cancelScheduledValues(ctx.currentTime);
            toneGain.gain.setValueAtTime(0.15 * vel, ctx.currentTime);
            toneGain.gain.setValueCurveAtTime(new Float32Array([0.15 * vel, 0.05 * vel, 0.01 * vel, 0]), ctx.currentTime, 0.10);
            noiseGain.gain.cancelScheduledValues(ctx.currentTime);
            noiseGain.gain.setValueAtTime(0.2 * vel, ctx.currentTime);
            noiseGain.gain.setValueCurveAtTime(new Float32Array([0.2 * vel, 0.15 * vel, 0.0]), ctx.currentTime, 0.15);
        }
    }
    return {
        play,
    }
}

return {
    SquareSynth,
    DrumSynth
}
}
	




// end of save/load

function start() {
 // initAC();

  document.getElementById("titleScreen").style.display = "none";
  document.getElementById("contentWrapper").style.display = "block";


}

document.addEventListener("DOMContentLoaded", () => {
document.getElementById("startBtn").addEventListener("click", start);
document.getElementById("generateBtn").addEventListener("click", () => {
        genTrack();
    });

    
});
</script>
</body>
</html>
